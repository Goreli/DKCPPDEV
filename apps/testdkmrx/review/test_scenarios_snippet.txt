################# Scenario 1: All in one module ######################
static struct : UnitTest  {
	virtual const string& getDescription() const noexcept {
		return "Description of test #1.";
	}
	virtual bool testFunction() const noexcept {
		// The test code goes here;
	}
} unitTest001;

static struct : UnitTest  {
	virtual const string& getDescription() const noexcept {
		return "Description of test #2.";
	}
	virtual bool testFunction() const noexcept {
		// The test code goes here;
	}
} unitTest002;

static GroupOfUnitTests groupOfTests001 { 
	"Example description of a group of unit tests.",
	{
		&unitTest001,
		&unitTest002
	}
};
######################################################################
################# Scenario 2: All in one module ######################
// These declarations are supposed to live in the library header file.

class GroupOfUnitTests {
public:
	GroupOfUnitTests(size_t iGroupSeqId, const char*) {/* Do the group registration here. */ }
};

struct UnitTest {
	UnitTest() {/* Do the test registration here. */}
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) = 0;
	virtual bool test() = 0;
};
//____________________________________________________________________
// These definitions live in the actual application test module.

static GroupOfUnitTests group001{
	1, "Example description of a group of unit tests."
};

static struct: UnitTest {
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) {
		group = group001;
		iTestSeqId = 1;
		sDescription = "Description of test #1.";
	}
	virtual bool test() {
		return true;
	}
} test001;

static struct : UnitTest {
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) {
		group = group001;
		iTestSeqId = 2;
		sDescription = "Description of test #2.";
	}
	virtual bool test() {
		return true;
	}
} test002;
################# Scenario 3: Several modules for the tests ##########
// These declarations are supposed to live in the library header file.

class GroupOfUnitTests {
public:
	GroupOfUnitTests(size_t iGroupSeqId, const char*) {/* Do the group registration here. */ }
};

struct UnitTest {
	UnitTest() {/* Do the test registration here. */ }
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) = 0;
	virtual bool test() = 0;
};
//____________________________________________________________________

// This module contains definitions of the groups used in the application.
GroupOfUnitTests group001{
	1, "Example description of a group of unit tests #1."
};
GroupOfUnitTests group002{
	2, "Example description of a group of unit tests #2."
};
//____________________________________________________________________

// This module contains definitions of tests pertaining to group 1.

extern GroupOfUnitTests group001;

static struct : UnitTest {
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) {
		group = group001;
		iTestSeqId = 1;
		sDescription = "Description of test #1 in group #1.";
	}
	virtual bool test() {
		return true;
	}
} test001;

static struct : UnitTest {
	virtual void ask(GroupOfUnitTests& group, size_t& iTestSeqId, std::string& sDescription) {
		group = group001;
		iTestSeqId = 2;
		sDescription = "Description of test #2 in group #1.";
	}
	virtual bool test() {
		return true;
	}
} test002;

######################################################################

################# Scenario 4: Several modules for the tests ##########
// These declarations are supposed to live in the library header file.

struct GroupOfUnitTests {
public:
	GroupOfUnitTests() {/* Do the group registration here. */ }
	virtual ~GroupOfUnitTests() {}

	// An override of the function to set the data members.
	virtual void identify() = 0;

protected:
	size_t _iGroupKey{ 0 };
	std::string _sDescription{ "" };
};

struct UnitTest {
	UnitTest() {/* Do the test registration here. */ }
	virtual ~UnitTest() {}

	// An override of the function to set the data members.
	virtual void identify() = 0;

	// An override of the function to execute the actual unit test.
	// The test should not allow any exceptions to be thrown. Any
	// exceptions occuring as part of the course of action should
	// be caught inside the function and the return value should be
	// derived accordingly.
	// Unhandled exceptions thrown from this function will be caught
	// by the library and Failed status will be reported.
	virtual bool test() = 0;

protected:
	size_t _iGroupKey{ 0 };
	size_t _iTestKey{ 0 };
	std::string _sDescription{ "" };
};
//____________________________________________________________________

// This module contains definitions of the groups used in the application.
static struct : GroupOfUnitTests {
	void identify() {
		_iGroupKey = 1;
		_sDescription = "Example description of a group of unit tests #1.";
	}
} group001;

static struct : GroupOfUnitTests {
	void identify() {
		_iGroupKey = 2;
		_sDescription = "Example description of a group of unit tests #2.";
	}
} group002;
//____________________________________________________________________

// This module contains definitions of tests pertaining to group 1.

static struct : UnitTest {
	void identify() {
		_iGroupKey = 1;
		_iTestKey = 1;
		_sDescription = "Description of test #1 in group #1.";
	}
	bool test() {
		bool bPassed{ true };
		// Do your testing here and set bPassed accordingly...
		return bPassed;
	}
} test001;

static struct : UnitTest {
	void identify() {
		_iGroupKey = 1;
		_iTestKey = 2;
		_sDescription = "Description of test #2 in group #1.";
	}
	bool test() {
		bool bPassed{ true };
		// Do your testing here and set bPassed accordingly...
		return bPassed;
	}
} test002;

######################################################################

################# Scenario 5: Several modules for the tests ##########
// These declarations are supposed to live in the library header file.

class GroupOfUnitTests {
public:
	GroupOfUnitTests(size_t iGroupKey, const char*) {/* Do the group registration here. */ }
};
//____________________________________________________________________

// This module contains definitions of the groups used in the application.
// Just a list. Note no variable names. Could use an array too supposidly.
static std::initializer_list<GroupOfUnitTests> groups{
	GroupOfUnitTests(1, "Description of group #1"),
	GroupOfUnitTests(2, "Description of group #2"),
	GroupOfUnitTests(3, "Description of group #3"),
	GroupOfUnitTests(4, "Description of group #4")
};

######################################################################
